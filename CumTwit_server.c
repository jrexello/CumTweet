/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "CumTwit.h"
#include <sys/stat.h>
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <errno.h>
extern int error; //El error de la union (Función de búsqueda)

void *
registrar_2_svc(usuario *argp, struct svc_req *rqstp) {
  /*Esta función sirva para registar un usuario. Se toman los datos facilitados por el cliente y se crean los ficheros del usuario.*/
    static char * result;

    FILE *fp = fopen("./serverCT/fusuarios", "a+"); //Si el fichero no existe, se crea.
    if (fp) { //Si el fichero se ha abierto correctamente
        char cad[200];
        strcpy(cad, argp->login);
        strcat(cad, ":");
        strcat(cad, argp->nombre);
        strcat(cad, ":");
        strcat(cad, argp->apellido);
        strcat(cad, ":");
        strcat(cad, argp->passwd);
        strcat(cad, ":");
        strcat(cad, argp->ciudad);
        strcat(cad, ":");
        strcat(cad, argp->pais);
        strcat(cad, ":");
        strcat(cad, argp->fecha);
        strcat(cad, "\n");
        fputs(cad, fp);
        fclose(fp);
        //Ahora creamos el fichero de los mensajes
        strcpy(cad, "./serverCT/fsms_send_");
        strcat(cad, argp->login);
        fp = fopen(cad, "a+"); //Se crea el fichero de mensajes enviados
        fclose(fp);

        strcpy(cad, "./serverCT/fsms_receive_");
        strcat(cad, argp->login);
        fp = fopen(cad, "a+"); //Se crea el fichero de mensajes recibidos
        fclose(fp);

        strcpy(cad, "./serverCT/fsms_read_");
        strcat(cad, argp->login);
        fp = fopen(cad, "a+"); //Se crea el fichero de mensajes leidos
        fclose(fp);


        printf("Usuario creado\n");
    } else {
        printf("Error al abrir el fichero\n");
    }

    return (void *) &result;
}

int *
enviar_2_svc(paquete *argp, struct svc_req *rqstp) {
  /*Esta función sirve para enviar un mensaje. Se toma el paquete generado por el cliente con la información del mensaje
   (Contenido, remitente y destinatario) se añade la hora del servidor y se copia la información a los ficheros de "Enviados" del remitente y al de "Recibidos" del destinatario.
   RETURN: 0: El si ha habido un error.
   		   1: Si se ha ejecutado correctamente.*/
  
    static int result;
	result = 0;
	char fecha[50]; //Aquí almacenamos la fecha
	char hora[50]; //Aquí almacenamos la hora
	char cad[100]; //Aquí almacenamos la ruta del fichero. Lo reusaremos para almacenar la cadena a escribir
    printf("Recibido mensaje de %s, para %s\n",argp->remite, argp->dest);
	//Primero transformamos la fecha a string
    time_t rawtime;
    if(time (&rawtime) == ((time_t) -1)){ //Error
		printf("Ha ocurrido un error al programar la fecha y hora.\n Error: %s\n", strerror(errno));
		return (int *)&result;
	}	
    struct tm *timeinfo = localtime (&rawtime );
    if(strftime (fecha, sizeof(fecha)-1, "%d/%m/%Y", timeinfo) == 0){ //Error
		printf("Ha ocurrido un error al guardar el string de la fecha.\n");
		return (int *)&result;
	}
	if(strftime (hora, sizeof(hora)-1, "%H.%M.%S", timeinfo) == 0){ //Error
		printf("Ha ocurrido un error al guardar el string de la hora.\n");
		return (int *)&result;
	}
    //Ahora "fecha" contiene la fecha
	FILE *fp, *fp2; //Lo usaremos para modificar los ficheros
	strcpy(cad, "./serverCT/fsms_send_");
    strcat(cad, argp->remite); //fp apuntará al fichero de "enviados" del remitente.
	fp = fopen(cad, "a");
	if(fp == NULL){ //Ocurre un error.
	  printf("Ha ocurrido un error al abrir el fichero de enviados.\n Error: %s\n", strerror(errno));
	  return (int *)&result;
	}
	//Reusamos cad
	strcpy(cad, "./serverCT/fsms_receive_");
    strcat(cad, argp->dest);
	fp2 = fopen(cad, "a"); //fp2 apuntará al fichero de "recibidos" del destinatario.
	if(fp2 == NULL){ //Ocurre un error.
	  printf("Ha ocurrido un error al abrir el fichero de enviados.\n Error: %s\n", strerror(errno));
	  return (int *)&result;
	}
	//Reutilizamos cad
	/*Ahora copiamos en el string cad el texto que añadiremos al fichero de "Enviados" con el siguiente prototipo:
	 destinatario:mensaje:dia/mes/año:Horas.Minutos.Segundos*/
	strcpy(cad, argp->dest);
	strcat(cad, ":");
	strcat(cad, argp->mess);
	strcat(cad, ":");
	strcat(cad, fecha);
	strcat(cad, ":");
	strcat(cad, hora);
	strcat(cad, "\n");
	fputs(cad, fp); //Escribimos el texto en el fichero
	//Reusamos cad
	/*Ahora copiamos en el string cad el texto que añadiremos al fichero de "Recibidos" con el siguiente prototipo:
	 remitente:mensaje:dia/mes/año:Horas.Minutos.Segundos*/
	strcpy(cad, argp->remite);
	strcat(cad, ":");
	strcat(cad, argp->mess);
	strcat(cad, ":");
	strcat(cad, fecha);
	strcat(cad, ":");
	strcat(cad, hora);
	strcat(cad, "\n");
	fputs(cad, fp2);
	//Cerramos los ficheros abiertos
	if(fclose(fp) != 0){//Hay un error
		printf("Ha ocurrido un error al cerrar el fichero de recibidos.\n Error: %s\n", strerror(errno));
		return (int *)&result;	  
	}
	if(fclose(fp2) != 0){
		printf("Ha ocurrido un error al cerrar el fichero de enviados.\n Error: %s\n", strerror(errno));
		return (int *)&result;
	}
	//Como se supone que todo ha ido bien, devolvemos 1.
	result = 1;
    return (int *) &result;
}

paquete *
leer_2_svc(credenciales *argp, struct svc_req *rqstp) {
	/*Función para leer los mensajes almacenanos. Recibimos del cliente las credenciales del usuario que auiere leer su buzón de entrada, le devolvemos el primero de los mensajes, lo copiamos en el fichero de "leidos" y lo borramos de "recibidos".*/
    static paquete result;
	char fecha[50]; //Aquí almacenamos la fecha
	char hora[50]; //Aquí almacenamos la hora
	char linea[256]; //Donde guardaremos las lineas leidas
	char nueva_linea[256]; //Aquí guardaremos la linea con la hora actualizada
	size_t len = 0; //Lo usaremos para leer 
	cadena remite_temp, fecha_temp, hora_temp; //Variables temporales en las que almacenaremos la información .
	mensaje mess_temp;
	//Comprobamos el login de quien queremos leer el mensaje
	FILE *fp, *fp2, *fp3; //fp = Mensaje recibidos. fp2 = Mensajes leidos. fp3= El archivo temporal para sobreescribir el de leidos
	char ruta[256];
	struct stat st = {0}; //Usaremos el stat para comprobar el fichero
	strcpy(ruta, "./serverCT/fsms_receive_");
	strcat(ruta, argp->login);
	fp = fopen(ruta, "r"); //Lo abrimos en modo lectura.
	if(fp == NULL){ //Si hay error al abrir el fichero, informamos sobre ello.
		printf("Error al abrir el fichero %s\nError: %s\n", ruta, strerror(errno));
		result.remite = strdup("");
		result.mess = strdup("");
		result.fecha = strdup("");
		result.hora = strdup("");
		result.dest = strdup("");
		fclose(fp);
	}else{
		if(stat(ruta,&st) != 0) printf("Error al comprobar el fichero\n");
		else{
			if(st.st_size == 0) {
			  printf("Fichero vacio\n");
			  result.remite = strdup("");
			  result.mess = strdup("");
			  result.fecha = strdup("");
			  result.hora = strdup("");
			  result.dest = strdup("");
			  fclose(fp);
			}//Si el fichero está vacio, terminamos.
			else{
		  	//Si no estaba vacío tomamos la primera línea.
			  	rewind(fp);
				if((fgets(linea, 250, fp)) != NULL){
			 	 	//Ahora abrimos el segundo fichero
					strcpy(ruta, "./serverCT/fsms_read_");
					strcat(ruta, argp->login);
					fp2 = fopen(ruta, "a");
					if(fp2 == NULL){ //Si hay error al abrir el fichero, informamos sobre ello.
						printf("Error al abrir el fichero %s\nError: %s\n", ruta, strerror(errno));
						result.remite = strdup("");
			  			result.mess = strdup("");
			 			result.fecha = strdup("");
			  			result.hora = strdup("");
			  			result.dest = strdup("");
			  			fclose(fp);
						fclose(fp2);
					}else{
						//Copiamos la linea leida en el fichero de leidos.
						time_t rawtime;   
    					time ( &rawtime );
    					struct tm *timeinfo = localtime ( &rawtime );
	    				strftime (fecha, sizeof(fecha)-1, "%d/%m/%Y", timeinfo);
						strftime (hora, sizeof(hora)-1, "%H.%M.%S", timeinfo);						
						remite_temp = strtok(linea, ":"); //Remitente
        				mess_temp = strtok(NULL, ":"); //Mensaje
        				fecha_temp = strtok(NULL, ":"); //Fecha
	        			hora_temp = strtok(NULL, ":"); //hora
						result.dest = strdup("");
						result.remite = strdup(remite_temp);
						result.mess = strdup(mess_temp);
						result.fecha = strdup(fecha_temp);
						result.hora = strdup(hora_temp);
						printf("Se va a enviar: Remitente: %s, Mess: %s, Fecha: %s, Hora: %s y dest: %s\n",result.remite, result.mess, result.fecha, result.hora, result.dest);
						//Actualizamos las horas
						strcpy(nueva_linea, result.remite);
						strcat(nueva_linea, ":");
						strcat(nueva_linea, result.mess);
						strcat(nueva_linea, ":");
						strcat(nueva_linea, fecha);
						strcat(nueva_linea, ":");
						strcat(nueva_linea, hora);
						strcat(nueva_linea, "\n");
						fputs(nueva_linea,fp2); //Añadimos el mensaje leido a la lista de mensaje leidos.
						//Ahora eliminamos la linea de recibidos.
						fp3 = fopen("./serverCT/Recibidos.tmp", "w");
						if(fp3 == NULL){ //Si hay error al abrir el fichero, informamos sobre ello.
							printf("Error al abrir el fichero temporal\n");
							result.remite = strdup("");
			  				result.mess = strdup("");
			 				result.fecha = strdup("");
			  				result.hora = strdup("");
			  				result.dest = strdup("");
			  				fclose(fp);
							fclose(fp2);
							fclose(fp3);
						}else{
							//Si se abre correctamente
					  		int temp = 1;
							rewind(fp); //Volvemos a poner el puntero al comienzo del fichero
							rewind(fp3);
							while( fgets(linea, sizeof(linea), fp) != NULL )
							{
    							if(temp != 1 ) fprintf(fp3, "%s", linea); 
    							temp++;
							}
        	    			//Ahora que tenemos el fichero creado, lo renombramos.
            				fclose(fp);
							fclose(fp2);
							fclose(fp3);
							strcpy(ruta, "./serverCT/fsms_receive_");
							strcat(ruta, argp->login); //La ruta al fichero de recibidos.
						  	remove(ruta); //Borramos el archivo original
        	    			rename("./serverCT/Recibidos.tmp", ruta); //Renombramos el nuevo.
						}
					}
				}else{
				  printf("No hay más lineas que tomar.\n");
				}
			}
		}
	}
	printf("Se va a enviar: Remitente: %s, Mess: %s, Fecha: %s, Hora: %s y dest: %s\n",result.remite, result.mess, result.fecha, result.hora, result.dest);
	printf("Peparándonos para salir...\n");
   // if (&result == (paquete *) NULL) printf ("Es null\n");
    return &result;
}

int *
existeuser_2_svc(cadena *argp, struct svc_req *rqstp) {
  
    /*Con este método comprobamos que las carpetas de usuario existen
	 * result = 0 No existe
	 * result = 1 Existe
	 * */
    static int result;
    result = 0;
    struct stat st = {0};

    if (stat("./serverCT", &st) == -1) {
        mkdir("./serverCT", 0700);
        FILE *fp = fopen("./serverCT/fusuarios", "a+");
        fclose(fp);
    }

    //Ahora buscamos por el usuario

    FILE *fp;
    char temp[512];
	cadena string_aux;
    //Abrimos el fichero para crearlo por si acaso
    fp = fopen("./serverCT/fusuarios", "a+");
    fclose(fp);
    if ((fp = fopen("./serverCT/fusuarios", "r")) == NULL) {
        result = 0;
    }

    while ((result == 0) && (fgets(temp, 512, fp) != NULL)) { //Tenemos en temp una línea
		string_aux = strtok(temp, ":");
        if ((strcmp(string_aux, *argp)) == 0) {
            result = 1;
            printf("El usuario ya existe\n");
        }
    }

    if (fp) {
        fclose(fp);
    }
    printf("Returnación del check: %d\n", result);
    return &result;
}

int *
eliminar_2_svc(credenciales *argp, struct svc_req *rqstp) {
  /*Esta funciópn busca los datos almacenados del usuario recibido por el cliente y elimina sus datos
   Return: 0: Si hay algún error
           1: Si se elimina correctamente*/
    static int result;
	result = 0;
    char linea[256]; //Donde guardaremos las lineas leidas
    cadena real_login, real_pass; //Aqui guardaremos la información guardada
    int encontrado = 0; //para saber cuando parar de buscar
    int num_linea = 0; //Para buscar la linea
    int temp = 1; //Para almacenar la linea en la que se encuentra
    cadena in_login, in_pass; //Aquí almacenamos los datos recibidos
    in_login = strdup(argp->login);
    in_pass = strdup(argp->passwd);
    int c; //Para realizar la copia del fichero temporal
    int cerrado = 0; //Para verificar si fp está cerrado.

    //Buscamos la linea
    FILE *fp, *fp2;
    fp = fopen("./serverCT/fusuarios", "r");
    while ((encontrado == 0)&&((fgets(linea, 256, fp)) != NULL)) { //Leemos una linea
        //sscanf(linea, "%s", linea);
		num_linea++;
        real_login = strtok(linea, ":");
        real_pass = strtok(NULL, ":"); //Nombre
        real_pass = strtok(NULL, ":"); //Apellido
        real_pass = strtok(NULL, ":"); //Pass
        
        //printf("%s%s\n",real_login,real_pass);
        if (strcmp(real_login, in_login) == 0) //Enconctramos el login
            encontrado = 1;
    }
    if (encontrado == 1) {
        if (strcmp(real_pass, in_pass) == 0) {
            printf("Contraseña aceptada!\n");
            //Iniciamos el proceso para borrar la linea
            fp2 = fopen("./serverCT/fusuarios.tmp", "w");
            rewind(fp);
            c = 0;
            while (c != EOF) {
                //printf("Char encontrado: %c", c);
                c = getc(fp);
				if(c != EOF){
                	if (temp != num_linea) { //Si no es la linea buscada, copiamos
                    	putc(c, fp2);
                	}
                if (c == '\n') temp++;
				}
            }
            fclose(fp);
			cerrado = 1;
            fclose(fp2);
            remove("./serverCT/fusuarios"); //Borramos el archivo original
            rename("./serverCT/fusuarios.tmp", "./serverCT/fusuarios"); //Renombramos el nuevo.
            //Ahora eliminamos los ficheros
            char ruta[100];
            strcpy(ruta, "./serverCT/fsms_read_");
            strcat(ruta, real_login); //Cone sto tenemos la ruita del fichero a borrar.
            remove(ruta);
            strcpy(ruta, "./serverCT/fsms_receive_");
            strcat(ruta, real_login); //Cone sto tenemos la ruita del fichero a borrar.
            remove(ruta);
            strcpy(ruta, "./serverCT/fsms_send_");
            strcat(ruta, real_login); //Cone sto tenemos la ruita del fichero a borrar.
            remove(ruta);
            result = 1;
        } else {
            //Contraseña incorrecta
            printf("Contraseña incorrecta!\n");
            result = 0;
        }
    }
    if(!cerrado) fclose(fp);
    return &result;
}

res_busqueda *
busca_2_svc(buscador *argp, struct svc_req *rqstp){
  /*Función de búsqueda. PD: SEA BUSCAR RECIBIDOS O ENVIADOS, EL CAMPO DE REMITE SERÁ EL QUE SE USE SIEMPRE PAR AALMACENAR EL LOGIN */
	static res_busqueda result;
	paquete pkt; //Paquete auxiliar en el que guardaremos la información
	lista nodo_b;// Puntero a nodo
	lista *siguiente;// Puntero a puntero
	char ruta[100]; //Donde almacenaremos la ruta de los ficheros.
	char linea[256]; //Variable para guardar la líneas que leamos
	cadena file_login, file_mess, file_fecha, file_hora; //Variables auxilires usadas para almacenar los datos leídos.
	FILE *fp; //Descriptor de fichero
	//Primero abrimos los ficheros necesarios
	if(argp->tipo == 1) strcpy(ruta, "./serverCT/fsms_receive_");
	else if(argp->tipo == 2) strcpy(ruta, "./serverCT/fsms_send_");
	//La precopndición implica que tipo solo puede ser 1 o 2.
	else exit(-1);
	strcat(ruta, argp->login); //Con esto tenemos la ruta del fichero
	fp = fopen(ruta, "r");
	if(fp == NULL){
		//Error
		printf("Ha ocurrido un error: %s\n", strerror(errno));
	}else{
		xdr_free(xdr_res_busqueda, &result); //Limpiamos el filtro por si acaso.
		siguiente = &result.res_busqueda_u.list; //result es un struct con una union dentro del mismo. Asignamos un puntero a si mismo.
		rewind(fp);
		
		while (fgets(linea, 255, fp) != NULL) { //Mientras siga habiendo líneas...
			
			//sscanf(linea, "%s", linea);
			
			file_login = strtok(linea, ":"); //Usuario
			file_mess = strtok(NULL, ":"); //Mensaje
			file_fecha = strtok(NULL, ":"); //Fecha
			file_hora = strtok(NULL, ":"); //La hora
			nodo_b = *siguiente = (nodo *) malloc(sizeof(nodo));  // reserva de memoria para el siguiente nodo
			if (nodo_b== (nodo *) NULL) // si no hay más elementos termina
					result.error = 2;
			//printf("Comparamos %s y %s y las fechas %s y %s\n", file_login, argp->login_buscado, file_fecha, argp->fecha);
			if(((strcmp(file_login, argp->login_buscado) == 0) || (strcmp(argp->login_buscado, " ") == 0)) && (strcmp(file_fecha, argp->fecha) ==0)){
				nodo_b->info.remite = strdup(file_login);    // guardamos los datos
				nodo_b->info.dest = strdup(file_login); //No se usará
				nodo_b->info.mess = strdup(file_mess);
				nodo_b->info.fecha = strdup(file_fecha);
				nodo_b->info.hora = strdup(file_hora);
				siguiente = &nodo_b->siguiente;   // guarda la dirección del siguiente elemento de la lista
			}
     	}//EndWhile
     	
	}//End Else
	
	*siguiente = (lista)NULL;   // El último elemento no apuntará a nada
    result.error = 0;           // no ha habido error
    fclose(fp);
	return &result;
}

int *
logearse_2_svc(credenciales *argp, struct svc_req *rqstp) {
    /*Errores:
     *  1 = Correcto
     * -1 = Error al recibir los datos
     * -2 = El usuario no existe
     * -3 = El usuario existe pero la pass es incorrecta
     * 
     */
    static int result;
    FILE *fp; //Para leer fusuarios
    cadena file_login, file_pass; //Aqui guardaremos la información guardada
    if (argp == NULL) result = -1; //Error
    else {
        cadena c_login = (*argp).login;
        cadena c_pass = (*argp).passwd;
        char linea[256]; //Donde guardaremos las lineas leidas
        int encontrado = 0;
        if (*existeuser_2_svc(&c_login, rqstp) != 1) result = -2; //El usuario no existe
        else {
		  	printf("ComprobaciÓn: %d\n", result);
            result = 0;
            printf("El usuario existe!\n");
            fp = fopen("./serverCT/fusuarios", "r");
            while ((encontrado == 0)&&((fgets(linea, 256, fp)) != NULL)) { //Leemos una linea
                sscanf(linea, "%s", linea);
                file_login = strtok(linea, ":");
                file_pass = strtok(NULL, ":"); //Nombre
                file_pass = strtok(NULL, ":"); //Apellido
                file_pass = strtok(NULL, ":"); //Pass

                //printf("%s%s\n",real_login,real_pass);
                if (strcmp(file_login, c_login) == 0) //Enconctramos el login
                    encontrado = 1;
            }
            if (encontrado == 1) {
                if (strcmp(file_pass, c_pass) == 0) {
                    printf("Contraseña aceptada!\n");
                    result = 1;
                } else {
                    result = -3;

                }
            }
            fclose(fp);
        }
    }


    printf("result: %d\n", result);
    return &result;
}

